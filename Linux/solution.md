# Solution

[요구 사항 분석서](./requirements_analysis.md)(주로 [가이드라인](../tetris%20guideline%20docs%202009/2009%20Tetris%20Design%20Guideline.pdf) 위주)의 내용을 실제로는 어떻게, 어디까지 구현했는지를 서술한다.

---

## Index

[주요 로직 설명](#주요-로직-설명)  

- [Q1. 전반적인 프로그램 흐름](#q1-전반적인-프로그램-흐름)
- [Q2. 테트로미노를 화면에 그리는 원리](#q2-테트로미노를-화면에-그리는-원리)

[소스코드별 설명](#소스코드별-설명)  

---


## 주요 로직 설명

### Q1. 전반적인 프로그램 흐름

우선 게임 흐름을 **겉으로 보이는 사용자와의 접점**만 감안하여 **사용자 입장**에서 작성해 보면 다음과 같다.  

(가이드라인에 따르면 원래는 `Esc`를 누르면 **EXIT**이 아니라 **PAUSE**를 해야 한다. 여력이 없어 **PAUSE**를 구현하지 못했다.  
또한 게임 오버 시에도 따로 메시지를 띄워서 한 판 더 할 것인지, 아님 게임 선택 화면으로 돌아갈 것인지 묻게끔 구현해야 하는데  
그러지 못하고 바로 게임을 시작하게끔 하였다.)

<img src = ../img/game_logic_1.png width="80%" height="80%">


이를 프로세스 관점에서 다시 보면 아래와 같다.  
(실제 함수 호출 구조나 로직은 좀 더 복잡하지만 편의상 주요 흐름 정도만 간단하게 표시했다.)

경과 시간을 표시하는 타이머(**Thread-2**)를 게임 루프(**Thread-1**)와 독립적으로 실행하기 위해  
멀티 스레스를 사용함을 알 수 있다.

(`Esc` 눌렀을 때 `exit()` 호출하는 건 어떻게 표현하지..?)


![Game Logic 2](../img/game_logic_2.png)

---

### Q2. 테트로미노를 화면에 그리는 원리

우선 이 게임에서 화면에 물체를 그리는 기본 원리는 [화가 알고리즘](https://ko.wikipedia.org/wiki/%ED%99%94%EA%B0%80_%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98)이다.  
마치 그림을 그릴 때의 방식처럼 가장 먼 배경부터 시작하여 가까운 순으로 물체를 그려나가는 전략을 일컫는다.

그럼 **콘솔창에 텍스트를 출력 하는 방식**을 사용한다면 이런 알고리즘을 어떻게 구현할 수 있을까?  
예를 들어 아래 [그림 1]과 같이 출력하고 싶다면 어떻게 해야 할까?

#### [그림 1]
<img src = ../img/tetris_game_play_screen_2.png width="70%" height="70%">

가장 간단한 방법은 전체 화면에 대한 정보를 2차원 배열에 저장하여 이를 출력하는 것이다.  
물체가 움직일 때마다 변경 사항을 배열에 반영하고 출력하면 된다.  
이를 실행하는 데에는 어느 정도의 연산이 필요할까?

대략 넉넉잡아 100 x 80 정도 크기의 배열이 필요하다고 가정해보자.  
60FPS라 가정하면 초당 100 x 80 x 60 = 480,000개의 문자를 터미널에 출력해야 한다.  
단순 고전 게임을 실행하는 것 치고는 연산량이 많다.  
좀 더 최적화를 해보고 싶다. 다른 방식은 없을까?  

출력 문자 수를 줄이는 방법으로 움직이는 물체만 출력하는 방식을 떠올려 볼 수 있다.  
물체의 **위치**와 **색**, **모양** 정보를 알고 있다면 물체만 따로 그릴 수 있다.  
물체가 움직일 때마다 현재 위치에 있는 물체를 지우고,  
새로운 위치에 물체를 다시 그리면 물체의 움직임을 표현할 수 있다.  
지운다는 표현을 썼는데, 정확히 말하면 물체를 배경색으로 다시 그리는 과정을 의미한다.

그럼 콘솔에서 어떻게 특정 위치에 출력할 수 있는가?  
커서를 옮겨야 한다.  
커서는 어떻게 이동시킬 수 있는가?  

고맙게도 리눅스 터미널은 콘솔 커서 이동과 관련된 [이스케이프 시퀀스](https://gist.github.com/fnky/458719343aabd01cfb17a3a4f7296797)를 지원해준다. (man page에 이스케이프 시퀀스 관련 문서로 [console_codes](https://man7.org/linux/man-pages/man4/console_codes.4.html)도 있긴 한데 이전 링크가 좀 더 친절함.) 

문서를 읽어보면 이것저것 기능이 많은데, 필요한 것만 추리면 다음과 같은 코드를 작성할 수 있다. 여러 이스케이프 시퀀스 코드를 조합하여 콘솔 출력 제어 함수를 만들어 낸다.  
(사실 어떤 원리인지 자세히 읽어보진 않았다. 프로젝트 중에는 [스택 오버플로 글](https://stackoverflow.com/questions/26423537/how-to-position-the-input-text-cursor-in-c)만 보고 넘어갔었다. 모든 걸 이해하려고 하면 프로젝트 진행이 넘 더뎌지는 것 같아 적당한 타협이 필요했다. 이건 이해보다는 익숙함의 영역인 듯ㅎ..)

```c
/* 콘솔 창 클리어 */
#define wclear() wprintf(L"[\eH\e[J")

/* 커서 지우기 */
#define wdisable_cursor() wprintf(L"\e[?25l")

/* 커서 보이기 */
#define wenable_cursor() wprintf(L"\e[?25h")

/* 커서 이동 */
#define wgotoxy(x, y) wprintf(L"\e[%d;%df", x + 1, y + 1);
```

---

### 멀티 스레드 구조 설계


### 게임 프레임(루프)


### 입력 이벤트 처리


---

## 소스코드별 설명


---
