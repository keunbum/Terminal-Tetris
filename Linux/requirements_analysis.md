# Requirements Analysis

<요구 사항 분석서>

게임을 설계하고 만들어 본 경험이 거의 없기 때문에  
전문가처럼 체계적이고 디테일한 요구 분석서를 작성하는 건 불가능하다.

요구 사항을 완벽하게 명시한 뒤에 코딩에 돌입하는 것이 아니라,  
설계/구현 루틴을 수없이 돌리는 방식을 택한다.
 
프로젝트가 어느 정도 진행되어 좀 더 그럴듯 하게 만들고 싶다면,  
[가이드라인](https://tetris.fandom.com/wiki/Tetris_Guideline) 참고하길 바람.

---

## Index

[TODO](#todo)

[Best Practice](#best-practice)  

[기능 요구 사항](#기능-요구-사항)  

  [Rule](#rule)  


[프로그래밍 요구 사항](#프로그래밍-요구-사항)  

[Coding Standard](#coding-standard)  

[Stuff you should look for](#stuff-you-should-look-for)



---

## TODO

- [ ] 테트로미노 모델링

- [ ] 게임 프레임(엔진)

  - [ ] 입력 출력 로직
  - [ ] 멀티 프로세스/쓰레드 프로그래밍 구조 설계  


---

- [ ] UI 설계
  - [ ] 테트로미노 블록에 색깔 어떻게 입힐지.

- [ ] HUD 설계

---

- [ ] 점수 시스템

- [ ] 사운드?


---

## Best Practice

이 정도 수준까지 구현하는 건 무리겠지만,
참고할 만한 구현물들.

- [TETRIS 99](https://namu.wiki/w/TETRIS%2099)
- [Tetris Effect](https://namu.wiki/w/Tetris%20Effect)
- [TETRIS](https://tetris.com/play-tetris) (아마 오리지널인듯?)

이걸 콘솔 상에서 구현해보는 것이 원하는 결과물.

---


## 기능 요구 사항

🔨 설계 진행 중..

### Rule

2차원 좌표계에 커다란 행렬(매트릭스)이 있다.  

게임이 시작되면

행렬의 스카이라인(상단 경계선)에서 테트로미노가 일정 주기로 1개씩 랜덤하게 나온다(spawn).  
테트로미노는 일정 속도로 아래 방향으로 떨어지며 바닥과 닿으면 정지한다.

플레이어는 테트로미노를 회전, 이동, 가속할 수 있다.  
(한번에 맨 아래 블럭에 닿게끔 하는 연산도 지원하면 좋을 듯.  
테트로미노(Tetromino)에 대해 자세히 알고 싶다면 -> [위키피디아](https://en.wikipedia.org/wiki/Tetromino))

빈 공간 없이 블록의 수평 행을 채우면 해당 라인이 클리어된다. (위에 있던 블록은 아래로 떨어짐)

테트로미노가 스카이라인을 넘어 서면 게임이 종료된다.

플레이어는 전략적으로 테트로미노 연산을 사용하여 최대한 버티면서 게임을 플레이 한다.

(점수 시스템도 있어야 하는데 이건 나중에)


---
 
### 입출력 요구 사항

#### 입력

#### 출력


---


## 프로그래밍 요구 사항

출처: [우테코 프리코스](https://github.com/woowacourse-precourse/java-lotto#-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D-%EC%9A%94%EA%B5%AC-%EC%82%AC%ED%95%AD)

반드시 지키자는 건 아니다.  
게임 프로그래밍과는 다른 부분도 있을 거다.  
그냥 이런 뉘앙스를 인지하고 프로그래밍 한다 정도?


- indent(인덴트, 들여쓰기) depth를 3이 넘지 않도록 구현한다. 2까지만 허용한다.
  - 예를 들어 while문 안에 if문이 있으면 들여쓰기는 2이다.
  - 힌트: indent(인덴트, 들여쓰기) depth를 줄이는 좋은 방법은 함수(또는 메서드)를 분리하면 된다.

- 3항 연산자를 쓰지 않는다.

- 함수(또는 메서드)의 길이가 15라인을 넘어가지 않도록 구현한다.
  - 함수(또는 메서드)가 한 가지 일만 하도록 최대한 작게 만들어라.

- else 예약어를 쓰지 않는다.
  - 힌트: if 조건절에서 값을 return하는 방식으로 구현하면 else를 사용하지 않아도 된다.
  - else를 쓰지 말라고 하니 switch/case로 구현하는 경우가 있는데 switch/case도 허용하지 않는다.

---

## Coding Standard

* [POCU 아카데미 C 코딩 표준](https://docs.popekim.com/ko/coding-standards/pocu-c)(Linux 프로그래밍용)

### 추가적으로 컨벤션 정의하기  

나 혼자 수행하는 프로젝트이므로 나에게 가장 편한 방식을 정하면 됨.  
결국엔 실수 덜하고 가독성 높이기 위한 방편이니까.

* `#define`은 [상수](https://docs.popekim.com/ko/coding-standards/pocu-c#:~:text=%EC%83%81%EC%88%98%20%EB%98%90%EB%8A%94%20%23define%20%EC%9C%BC%EB%A1%9C%20%EC%A0%95%EC%9D%98%EB%90%9C%20%EC%83%81%EC%88%98%EC%9D%98%20%EC%9D%B4%EB%A6%84%EC%9D%80%20%EB%AA%A8%EB%91%90%20%EB%8C%80%EB%AC%B8%EC%9E%90%EB%A1%9C%20%ED%95%98%EB%90%98%20%EB%B0%91%EC%A4%84%EB%A1%9C%20%EA%B0%81%20%EB%8B%A8%EC%96%B4%EB%A5%BC%20%EB%B6%84%EB%A6%AC%ED%95%9C%EB%8B%A4.) 말고도 `매크로 함수`를 정의하기 위해 쓰이기도 하는데  
  이때도 대문자로 작성? or 소문자?  
  더 근본적으론 `#define`으로 함수를 정의할 필요가 있는가? 어차피 컴파일러가 알아서 인라인 최적화 해주지 않을까?  
  물론 일반 함수로는 대체될 수 없는 것도 있을 순 있음. 구조체 선언 같은 거. 이거는 그래서 대문자로 작성하긴 함.

* 가급적이면 `#define` 보다는 `static inline` 함수를 사용한다.  
  잘못된 타입을 넘겨주는 것을 방지하기 위함.  
  가변 인자와 같이 다루기 까다로운 것만 `매크로 함수` 사용하는 걸로.

* ~~포인터형 변수에는 뒤에 `_ptr`을 붙인다. (아직 시험 운행 중)~~

* ~~내부적으로 `pthread`나 `fork` 등 스레드(프로세스)를 생성하는 함수는 앞에 `run_`을 붙인다.  
  이제보니 안쓰는데 `run_` 붙은 것도 있는데;~~

* 내부에 lock, unlock 로직이 있는 함수는 뒤에 `_r`을 붙인다.

* [동적 할당 컨벤션](https://docs.popekim.com/ko/coding-standards/pocu-c#:~:text=%EB%82%B4%EB%B6%80%EC%97%90%EC%84%9C%20%EB%8F%99%EC%A0%81%EC%9C%BC%EB%A1%9C%20%EB%A9%94%EB%AA%A8%EB%A6%AC%EB%A5%BC%20%ED%95%A0%EB%8B%B9%ED%95%98%EB%8A%94%20%ED%95%A8%EC%88%98%EC%9D%98%20%EC%9D%B4%EB%A6%84%EC%9D%80%20%EB%B0%98%EB%93%9C%EC%8B%9C%20_malloc%EC%9C%BC%EB%A1%9C%20%EB%82%9C%EB%8B%A4.)에 대응하여 내부적으로 동적 메모리 해제를 하는 함수는 뒤에 `_free`를 붙인다.

* 구조체를 비롯한 객체의 `init` 함수가 정의되었다면 반드시 그에 상응하는 `cleanup` 함수를 정의한다.  
  내부적으로 정리할 요소가 없는 구조체라도 빈 `cleanup` 함수를 정의하여 호출한다. (코드 가독성이나 추후에 확장성을 위함.)

* 배열 인덱싱 변수에는 가급적 i, j, k, ...을 포함한다. (객체의 좌표 변수와 배열 인덱싱을 혼용하지 않도록 하기 위함.)

* `for`문 내부에서 쓰이지 않는 카운트 변수는 `_`(Underscore. under-bar라고도 한다.)로 선언한다.

  대개 `for`문을 아래와 같이 작성하곤 하는데  
  ```c
  for (int i = 0; i < 10; ++i) {
      ...
  }
  ```
  변수 `i`가 중괄호 안에서 쓰이지 않는다면 
  ```c
  for (int _ = 0; _ < 10; ++_) {
      ...
  }
  ```
  이런 식으로 변수를 선언하자는 뜻. (파이썬의 `for _ in range(10)`과 유사)  

  매크로를 사용한다면 아래와 같이 작성할 수도 있겠다.

  ```c
  #define forn(i, n) for (int i = 0; i < n; ++i)

  forn(_, 10) {
      ...
  }
  ```

  `while`문을 이용하는 방법도 있긴 한데, 변수의 범위(scope)가 커지므로 `while`문보다는 `for`문을 선호한다.
  ```c
  int _ = 10;
  while (_-- > 0) {
      ...
  }
  ```

---

## Stuff you should look for

* 매크로 정의할 때 표준 라이브러리에 선언된 것과 겹치지 않도록 주의!!  
* 어떤 코딩 컨벤션을 사용하든지 정답은 없다.  
  단, 어떤 규칙을 따르기로 했으면 그 일관성을 유지할 것.  
* 매크로, 구조체, 공용체, 함수 중 사용하지 않는 건 과감하게 다 지울 것. (실수할 여지가 많다.)  
* `assert` 쓰는 걸 주저하지 말자.  
  버그는 일찍 알아챌수록 좋다.
* `char[]`나 `wchar_t[]` 출력할 때 끝에 널 문자(`'\0'`, `L'\0'`) 넣기.  
* null pointer exception 유의  
* `exit` 류의 시스템 콜을 사용할 때는 안닫힌 파일이나 그밖에 정리되지 않은 항목은 없는지 잘 확인해 줄 것.
* 주요 시스템 콜이 실패했는지 확인하는 로직 빼먹지 말고 작성.  
  ```c
  if (smth_syscall(...) == -1) {
      handle_error("smth_syscall() error");
  }
  ```
* 문자열을 출력할 때는 `%c` 여러번 보다 버퍼에 모아두었다가 한번에 `%s` 출력이 좋은 것 같다.  
* 코드리뷰가 IDE보다 깃허브에서 더 잘됨;  
  리팩토링 하려면 `깃허브`에서 볼 것. (물론 평소에도 꼼꼼하게 봐야지)
* 너무 객체지향적으로 짜려고 하지 말 것. 적당히 타협해야 함.  
* `static 변수` 적절하게 사용할 것. `지역 변수`로 선언해서 인수로 주소를 넘겨주는 행위는 멀티 스레딩에서 오작동 할 여지가 있다.  
  전역이나 지역 `static`으로 선언해서 넘겨주는 방식 선호.  
  (동적 할당도 있지만 메모리 누수 신경써야 하고 코드 복잡해지므로 쉬운 방법 선호)  
* 상수 일일이 `#define` 하지 말고 `enum` 애용하기. (단 `int`형만 저장할 수 있음에 유의)
* 인수 넘겨줄 때 타입 안맞으면 형변환 하기.
